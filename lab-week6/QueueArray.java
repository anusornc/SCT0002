/*
	CLASS : QueueArray
*/
public class QueueArray<T> implements Queue<T> {

    private T[] arr;	// กำหนดตัวแปรอะไร ระบุชนิดข้อมูลเป็นแบบกลางๆ (Generic)
					  //head, tail
    private int total, first, next;	// กำหนดตัวแปรสำหรับใช้งานคือ จำนวนข้อมูลทั้งหมด , ข้อมูลชุดแรก , ข้อมูลชุดถัดไป

	// Contructor
    public QueueArray() {
        arr = (T[]) new Object[2];	// กำหนดให้มีอะเรย์เริิ่มต้นเมื่อเรียกใช้งาน Class ขนาด 2 ห้อง
    }

	/*
		เมธอดสำหรับการขยายขนาดของอะเรย์แบบอัตโนมัติ
		ขั้นตอนคือทำการสร้างอะเรย์ใหม่
		จากนั้นทำการคัดลอกข้อมูลจากอะเรย์เก่าไปยังอะเรย์ตัวใหม่
		และสุดท้ายคือกำหนดค่าอะเรย์ที่ใช้งานเป็นอะเรย์ตัวใหม่ที่มีข้อมูลสมบูรณ์(จากการคัดลอกก่อนหน้านี้)
		พร้อมขนาดอะเรย์ที่เพิ่มขึ้น
		
		Parameter : capacity (รับค่าขนาดของอะเรย์ใหม่ที่ต้องการขยาย)
	*/
    private void resize(int capacity) {
    	@SuppressWarnings("unchecked")
        T[] tmp = (T[]) new Object[capacity];			// ทำการสร้างอะเรย์ตัวใหม่มีขนาดตามที่รับค่ามา

        for (int i = 0; i < total; i++)					// ทำการคัดลอกข้อมูลจากอะเรย์เก่า
            tmp[i] = arr[(first + i) % arr.length];

        arr = tmp;		 // กำหนดค่าให้อะเรย์ตัวใหม่เป็นอะเรย์ที่ใช้งานปัจจุบัน
        first = 0;		 // กำหนดให้ ตัวชี้ตำแหน่งแรกกลับไปที่ลำดับ 0 
        next = total;	 // กำหนดให้ ตัวชี้ตำแหน่งถัดไปคือลำดับที่ตรงกับจำนวนข้อมูลในอะเรย์ทั้งหมด
    }

	/*
		เมธอดสำหรับการนำข้อมูลเข้าสู่แถวคอย
		Parameter:ele ข้อมูลที่จะนำเข้าสู่แถวคอย
	*/
    public QueueArray<T> enqueue(T ele) {
    	// ถ้าหากขนาดของอะเรย์มีค่าเท่ากับข้อมูลทั้งหมดในอะเรย์
    	// ให้ขยายขนาดของอะเรย์ออกไปก่อนอีกสองเท่าของขนาดอะเรย์ปัจจุบัน
    	System.out.print("arr.length =" + arr.length+" and total =" + total);
        if (arr.length == total) resize(arr.length * 2);	
        
        // นำข้อมูลเข้าไปเก็บในแถวคอย ณ ตำแหน่งหลังสุด
        arr[next++] = ele;	
        	
        // ถ้าหากตำแหน่งตัวชี้ข้อมูลลำดับถัดไป มีค่าตรงกับขนาดของอะเรย์พอดีให้ next กลับไปชี้ที่ตำแหน่งแรกใหม่
        if (next == arr.length) next = 0;
        
        System.out.println("current next ="+next);
        // เพิ่มค่าตัวนับจำนวนข้อมูลในแถวคอยอีก 1 ตัว	
        total++;
        
        // คืนค่าทั้ง Class นี้กลับไปยังต้นทาง
        return this;
    }

	/*
		เมธอดสำหรับการนำข้อมูลออกจากแถวคอย
		เนื่องจาก แถวคอยคือ เข้าก่อน ออกก่อน (First In First Out)
		ดังนั้นไม่ต้องมีการระบุพารามิเตอร์ก็ทราบว่าต้องเอาตัวใดออกจากแถวคอยก่อน
	*/
    public T dequeue()  {
    	// ถ้าหากจำนวนข้อมูลในแถวคอยเท่ากับศูนย์ ก็ไม่ต้องทำอะไร แค่แสดง Error ให้ผู้ใช้งานทราบ
        if (total == 0) throw new java.util.NoSuchElementException();
        
        // กำหนดให้ตัวแปร ele เก็บข้อมูลของตัวที่จะออกจากแถวคอยซึ่งก็คือตัว ณ ตำแหน่งที่ ตัวแปร first เก็บค่าอยู่
        // เป็นการใช้อะเรย์แบบวนไปเรื่อยดังนั้นตัวแรกหมายถึงตัวที่ first ชี้อยู่ปัจจุบัน ไม่ใช่อะเรย์ลำดับ 0 เสมอไป
        T ele = arr[first];
        
        // ทำการลบข้อมูลออกจากแถวคอยใน
        arr[first] = null;
        
        // ถ้าหาก fist เมื่อเพิ่มค่าแล้วเท่ากับขนาดของอะเรย์ให้ fist กลับไปชี้ที่อะเรย์ ลำดับ 0 ใหม่
        if (++first == arr.length) first = 0;
        
        // ถ้าหากลดค่าของจำนวนข้อมูลในอะเรย์แล้วยังมีค่ามากกว่า 0 และ 
        // ขนาดของอะเรย์เมื่อนำมาหารด้วย 4 แล้วมีค่าเท่ากันกับจำนวนข้อมูลให้ทำการลดขนาดของอะเรย์ลงเพื่อประหยัดพื้นที่การใช้งาน
        if (--total > 0 && total == arr.length / 4) resize(arr.length / 2);
        
        // คือค่าข้อมูลที่เก็บเอาไว้ก่อนลบออกจากแถวคอยกลับออกไป
        return ele;
    }

    @Override
    public String toString()
    {
        return java.util.Arrays.toString(arr);	// แสดงข้อมูลในแถวคอย
    }

}
